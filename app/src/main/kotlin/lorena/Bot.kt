/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package lorena

import discord4j.core.DiscordClient
import discord4j.core.event.domain.message.MessageCreateEvent
import discord4j.core.event.domain.message.ReactionAddEvent
import discord4j.core.event.domain.message.ReactionRemoveEvent
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.reactive.asFlow
import kotlinx.coroutines.reactive.awaitSingle
import kotlinx.coroutines.reactor.mono
import io.github.cdimascio.dotenv.dotenv
import org.jetbrains.exposed.sql.Database

class Bot {
    val dotenv = dotenv()
    val db = Database.connect(dotenv["DB_HOST"], driver = "com.mysql.jdbc.Driver", user = dotenv["DB_USER"], password = dotenv["DB_PASS"])

    val testingFlag = true
}

fun main(args: Array<String>) {
    val client = DiscordClient.create(Bot().dotenv["TOKEN"])
    
    client.withGateway {
        mono {
            //Bot commands list
            it.on(MessageCreateEvent::class.java)
                    .asFlow()
                    .collect {
                        val message = it.message
                        val parsedMessage = message.content.split(" ")
                        if(!(Bot().testingFlag && message.channelId.asString() != "795392960697991248")) {
                            if (parsedMessage[0] == "!lore") {
                                when (parsedMessage[1]) {
                                    "ping" -> {
                                        println("ping")
                                        val channel = message.channel.awaitSingle()
                                        channel.createMessage("Pong!").awaitSingle()
                                    }

                                    "marco" -> {
                                        val channel = message.channel.awaitSingle()
                                        channel.createMessage("Polo!").awaitSingle()
                                    }

                                    "usercount" -> {
                                        val channel = message.channel.awaitSingle()
                                        channel.createMessage("usercount not implemented yet").awaitSingle()
                                    }

                                    "list" -> {
                                        when (parsedMessage[2]) {
                                            "me" -> {
                                                val channel = message.channel.awaitSingle()
                                                channel.createMessage("list me not implemented yet").awaitSingle()
                                            }

                                            "all" -> {
                                                val channel = message.channel.awaitSingle()
                                                channel.createMessage("list all not implemented yet").awaitSingle()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
            /* Reaction event handling*/
            // Added Reaction
            it.on(ReactionAddEvent::class.java)
                    .asFlow()
                    .collect {
                        println("collected new reaction")
                    }
            // Removed Reaction
            it.on(ReactionRemoveEvent::class.java)
                    .asFlow()
                    .collect {
                        println("collected deleted reaction")
                    }
        }
    }
            .block()
}
